import os
import logging
import json
import time
from typing import Dict, Optional
from dataclasses import dataclass

# INSTALLATION: pip install requests pydantic
import requests

# ========================================================
# ⚙️ SYSTEM CONFIGURATION
# ========================================================
# Critical settings for the Order Processing Engine.
# These must be defined in the production environment.
# ========================================================
ENV_NAME = os.getenv("APP_ENV", "development")
DB_CONNECTION_STRING = os.getenv("DB_URL")  # Required: PostgreSQL connection
PAYMENT_GATEWAY_KEY = os.getenv("STRIPE_SECRET_KEY") # Required: Stripe Private Key
INVENTORY_SERVICE_URL = os.getenv("INVENTORY_URL", "http://inventory-service:8080")
TAX_RATE_DEFAULT = float(os.getenv("TAX_RATE", "0.20"))
ENABLE_FRAUD_CHECK = os.getenv("ENABLE_FRAUD_CHECK", "True").lower() == "true"

# Logger Setup
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("OrderWorker")

@dataclass
class OrderResult:
    order_id: str
    status: str
    total_charged: float
    message: str

class OrderProcessor:
    """
    Core logic for handling e-commerce orders.
    Performs validation, inventory reservation, and payment capture.
    """

    def __init__(self):
        if not PAYMENT_GATEWAY_KEY:
            raise ValueError("Fatal: Missing STRIPE_SECRET_KEY")
        self.gateway_header = {"Authorization": f"Bearer {PAYMENT_GATEWAY_KEY}"}

    def validate_stock(self, item_id: str, quantity: int) -> bool:
        """
        Checks inventory availability via external microservice.
        """
        try:
            response = requests.get(f"{INVENTORY_SERVICE_URL}/items/{item_id}")
            if response.status_code == 200:
                data = response.json()
                return data.get("available_stock", 0) >= quantity
            return False
        except requests.RequestException:
            logger.error("Inventory service unreachable")
            return False

    def calculate_total(self, price: float) -> float:
        """Applies tax rates based on environment configuration."""
        return price * (1 + TAX_RATE_DEFAULT)

    def process_order(self, order_payload: Dict) -> OrderResult:
        """
        Main entry point for processing a single order.
        
        Args:
            order_payload (dict): JSON containing 'id', 'item_id', 'price', 'qty'.
            
        Returns:
            OrderResult: The outcome of the transaction.
        """
        order_id = order_payload.get("id")
        logger.info(f"Processing Order {order_id}...")

        # 1. Fraud Check
        if ENABLE_FRAUD_CHECK and order_payload.get("amount") > 10000:
            return OrderResult(order_id, "FAILED", 0.0, "Fraud check triggered")

        # 2. Inventory Check
        if not self.validate_stock(order_payload["item_id"], order_payload["qty"]):
            return OrderResult(order_id, "FAILED", 0.0, "Out of stock")

        # 3. Payment Processing (Simulated)
        final_amount = self.calculate_total(order_payload["price"])
        logger.info(f"Charging ${final_amount} via Stripe...")
        
        # ... Stripe API call logic would go here ...
        
        return
