name: ü§ñ Documentation Agent (Gemini)

on:
  pull_request:
    types: [opened, synchronize, labeled]
  workflow_dispatch:
    inputs:
      mode:
        description: 'Scan Mode'
        required: true
        default: 'diff'
        type: choice
        options:
        - diff
        - full_scan

permissions:
  pull-requests: write
  contents: write

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - name: 1. Check out code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0

      - name: 2. Gather Data
        id: file_data
        run: |
          git fetch origin ${{ github.base_ref }} || true
          
          MODE="${{ github.event.inputs.mode }}"
          if [ "${{ github.event_name }}" == "pull_request" ]; then
             MODE="diff"
          fi
          
          if [ "$MODE" == "diff" ]; then
             git diff origin/${{ github.base_ref }} HEAD -- . ":(exclude).github" ":(exclude).gitignore" > pr_diff.txt
          elif [ "$MODE" == "full_scan" ]; then
             find . -maxdepth 4 -not -path '*/.*' -not -path './node_modules*' | grep -E "\.(py|js|ts|go|java|md|json)$" > all_files_list.txt
             echo "FULL SCAN" > pr_diff.txt
             while read -r file; do
               echo "--- FILE: $file ---" >> pr_diff.txt
               cat "$file" >> pr_diff.txt
               echo "" >> pr_diff.txt
             done < all_files_list.txt
          else
             echo "No changes." > pr_diff.txt
          fi

          if [ -f "README.md" ]; then
            cp README.md current_readme.txt
          else
            echo "README.md file not found." > current_readme.txt
          fi
          
          git ls-files --exclude-standard | grep -v "^.github/" > file_tree.txt || true

      # ========================================================
      # üõ† –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 1: –ß–ê–°–û–í–û–ô –ü–û–Ø–°
      # ========================================================
      - name: 3. Generate PR Description
        if: github.event_name == 'pull_request'
        id: pr_desc_gen
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          # ‚¨áÔ∏è –£–°–¢–ê–ù–û–í–ò–¢–ï –í–ê–® –ß–ê–°–û–í–û–ô –ü–û–Ø–° (–ù–∞–ø—Ä–∏–º–µ—Ä: Europe/Moscow, Asia/Dubai)
          TZ: "Europe/Moscow" 
        run: |
          # –ü–æ–ª—É—á–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –≤—Ä–µ–º—è
          CURRENT_DATE=$(date +'%Y-%m-%d %H:%M')
          
          cat <<'EOF_PROMPT' > pr_prompt.txt
          # TASK: PR UPDATE LOGGER
          Generate a short log entry for this code update.
          # OUTPUT FORMAT:
          ### üîÑ Update (__DATE__)
          * [Emoji] [Short bullet point about changes]
          * [Emoji] [Another bullet point]
          # RULE: Be concise. No intro text.
          EOF_PROMPT
          
          # –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –≤—Å—Ç–∞–≤–∫–∞ –¥–∞—Ç—ã
          sed -i "s/__DATE__/$CURRENT_DATE/g" pr_prompt.txt

          jq -n \
            --rawfile diff pr_diff.txt \
            --rawfile prompt pr_prompt.txt \
            '{ contents: [{ parts: [{ text: ($prompt + "\n\n## DIFF:\n" + $diff) }] }] }' > pr_payload.json

          curl -s -H "Content-Type: application/json" \
               -d @pr_payload.json \
               "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=$GEMINI_API_KEY" > pr_response.json
          
          jq -r '.candidates[0].content.parts[0].text' pr_response.json > pr_update_block.md

      # ========================================================
      # üõ† –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 2: –ë–ï–ó–û–ü–ê–°–ù–û–ï –î–û–ë–ê–í–õ–ï–ù–ò–ï –ò–°–¢–û–†–ò–ò
      # ========================================================
      - name: 4. Update PR Body (Safe Append)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            if (!fs.existsSync('pr_update_block.md')) return;
            
            const newBlock = fs.readFileSync('pr_update_block.md', 'utf8');
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            let currentBody = pr.body || "";
            const LOG_HEADER = "## üöÄ AI Summary Log";
            
            // –ï—Å–ª–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞ –µ—â–µ –Ω–µ—Ç, —Å–æ–∑–¥–∞–µ–º –µ–≥–æ –∏ –¥–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–≤—É—é –∑–∞–ø–∏—Å—å
            if (!currentBody.includes(LOG_HEADER)) {
               currentBody = LOG_HEADER + "\n\n" + newBlock + "\n\n---\n" + currentBody;
            } 
            else {
               // –ï—Å–ª–∏ –∑–∞–≥–æ–ª–æ–≤–æ–∫ –µ—Å—Ç—å, –º—ã –≤—Å—Ç–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å –°–†–ê–ó–£ –ü–û–°–õ–ï –Ω–µ–≥–æ.
               // –°—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏ —Å–¥–≤–∏–≥–∞—é—Ç—Å—è –≤–Ω–∏–∑, –Ω–æ –ù–ï —É–¥–∞–ª—è—é—Ç—Å—è.
               currentBody = currentBody.replace(LOG_HEADER, LOG_HEADER + "\n\n" + newBlock);
            }
            
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              body: currentBody
            });

      - name: 5. Generate README
        id: gemini_readme
        env:
          REPO_NAME: ${{ github.event.repository.name }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          cat <<'EOF_PROMPT' > readme_prompt.txt
          # TASK: DOCUMENTATION ARCHITECT
          ## GOAL: Update `README.md` with visual polish.
          
          ## VISUAL RULES:
          1. **BADGES:** Add Shields.io badges under the title.
          2. **FILE TREE:** Add `## üìÇ Project Structure` section with a tree view.
          3. **TABLES:** Use Markdown tables for Config/Env vars.
          
          ## STANDARD RULES:
          1. **ALWAYS UPDATE:** Generate full content.
          2. **INTEGRATION:** Merge new features.
          
          ## OUTPUT FORMAT:
          Split response with "---SPLIT---".
          **PART 1: CHANGE LOG**
          ---SPLIT---
          **PART 2: FULL README**
          
          ## GOLDEN STRUCTURE:
          ---
          **[GOLDEN_TEMPLATE]**
          # PROJECT_NAME_PH
          [Badges]
          [Description]
          ## 1. Table of Contents
          ## 2. About The Project
          ## üìÇ Project Structure
          ## 3. Installation
          ## 4. Usage
          ## 5. Configuration
          ## 6. API Reference
          ## 7. Deployment
          ## 8. Roadmap
          ## 9. License
          Copyright ¬© 2025 Grid Dynamics Holdings, Inc. All rights reserved.
          (Standard License Text...)
          ---
          EOF_PROMPT

          sed -i "s/PROJECT_NAME_PH/$REPO_NAME/g" readme_prompt.txt
          
          jq -n \
            --arg repo "$REPO_NAME" \
            --rawfile diff pr_diff.txt \
            --rawfile readme current_readme.txt \
            --rawfile filetree file_tree.txt \
            --rawfile prompt readme_prompt.txt \
            '{ contents: [{ parts: [{ text: ($prompt + "\n\n## FILES:\n" + $filetree + "\n\n## README:\n" + $readme + "\n\n## CODE CONTENT:\n" + $diff) }] }] }' > readme_payload.json

          curl -s -H "Content-Type: application/json" -d @readme_payload.json "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=$GEMINI_API_KEY" > readme_response.json
          
          jq -r '.candidates[0].content.parts[0].text' readme_response.json | sed 's/^```json//' | sed 's/^```//' | sed 's/```$//' > gemini_output.txt

      - name: 6. Decide Action
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            if (!fs.existsSync('gemini_output.txt')) return;
            const fullOutput = fs.readFileSync('gemini_output.txt', 'utf8');
            
            const separator = "---SPLIT---";
            let summary = "Documentation updated.";
            let readmeContent = fullOutput;

            if (fullOutput.includes(separator)) {
               const parts = fullOutput.split(separator);
               summary = parts[0].trim();
               readmeContent = parts[1].trim();
            }

            if (context.eventName === 'pull_request') {
                const labels = context.payload.pull_request ? context.payload.pull_request.labels.map(l => l.name) : [];
                const shouldCommit = labels.includes('generate-readme');

                if (shouldCommit) {
                  console.log("LABEL FOUND! Writing file...");
                  fs.writeFileSync('README.md', readmeContent);
                } else {
                  console.log("Updating comment...");
                  const header = "ü§ñ **Documentation Agent**";
                  const body = `${header}\n\n### üìù Change Log:\n${summary}\n\n---\nüëâ **Apply?** Add label **\`generate-readme\`**.\n\n<details><summary>üëÄ View README</summary>\n\`\`\`markdown\n${readmeContent}\n\`\`\`\n</details>`;
                  
                  const { data: comments } = await github.rest.issues.listComments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                  });
                  const botComment = comments.find(c => c.body.includes(header));
                  if (botComment) {
                    await github.rest.issues.updateComment({ owner: context.repo.owner, repo: context.repo.repo, comment_id: botComment.id, body: body });
                  } else {
                    await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number, body: body });
                  }
                }
            } else {
                console.log("MANUAL RUN DETECTED. Printing README to logs:");
                console.log(readmeContent);
            }

      - name: 7. Commit Changes
        if: github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'generate-readme')
        run: |
          git config --global user.name "Gemini Docs Agent"
          git config --global user.email "actions@github.com"
          git add README.md
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "docs: auto-update README.md [skip ci]"
            git push
            curl -L -X DELETE -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "[https://api.github.com/repos/$](https://api.github.com/repos/$){{ github.repository }}/issues/${{ github.event.number }}/labels/generate-readme"
          fi
