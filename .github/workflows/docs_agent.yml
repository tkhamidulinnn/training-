name: ü§ñ Documentation Agent (Gemini)

on:
  pull_request:
    types: [opened, synchronize, labeled]
  workflow_dispatch:

permissions:
  pull-requests: write
  contents: write

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - name: 1. Check out code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0

      - name: 2. Gather Data
        id: file_data
        run: |
          git fetch origin ${{ github.base_ref }}
          
          # 1. Collect Diff
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            git diff origin/${{ github.base_ref }} HEAD -- . ":(exclude).github" ":(exclude).gitignore" > pr_diff.txt
          else
            echo "Not a PR (manual run)." > pr_diff.txt
          fi

          # 2. Collect Current README
          if [ -f "README.md" ]; then
            cp README.md current_readme.txt
          else
            echo "README.md file not found." > current_readme.txt
          fi
          
          # 3. Collect File Structure
          git ls-files --exclude-standard | grep -v "^.github/" > file_tree.txt

      - name: 3. Call Gemini API
        id: gemini_call
        env:
          REPO_NAME: ${{ github.event.repository.name }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          cat <<'EOF_PROMPT' > prompt_instructions.txt
          # TASK: DOCUMENTATION MAINTAINER
          ## GOAL: Update `README.md` based on code changes.
          
          ## RULES:
          1. **ALWAYS UPDATE:** Generate the full `README.md`.
          2. **INTEGRATION:** Merge new features into the existing structure.
          3. **FORMAT:** Use clear Markdown.
          
          ## OUTPUT FORMAT:
          You MUST split the output into two parts separated by "---SPLIT---".
          
          **PART 1: CHANGE LOG** - A concise bulleted list of what changed.
          - Group by filename using emoji (e.g., üìÇ `src/main.js`).
          
          ---SPLIT---
          
          **PART 2: FULL README**
          - The complete, updated Markdown content of the README.md file.
          
          ## GOLDEN STRUCTURE (Follow this structure):
          ---
          # [Project Name]
          [Description]
          ## 1. Table of Contents
          ## 2. About The Project
          ## 3. Installation
          ## 4. Usage
          ## 5. Configuration
          ## 6. API Reference
          ## 7. Deployment
          ## 8. Roadmap
          ## 9. License
          Copyright ¬© 2025 Grid Dynamics Holdings, Inc. All rights reserved.
          ---
          EOF_PROMPT

          sed -i "s/PROJECT_NAME_PH/$REPO_NAME/g" prompt_instructions.txt
          
          echo -e "\n\n## CURRENT FILE TREE:\n" >> prompt_instructions.txt
          cat file_tree.txt >> prompt_instructions.txt
          echo -e "\n\n## CURRENT README:\n" >> prompt_instructions.txt
          cat current_readme.txt >> prompt_instructions.txt
          echo -e "\n\n## PR DIFF:\n" >> prompt_instructions.txt
          cat pr_diff.txt >> prompt_instructions.txt

          jq -n --rawfile prompt prompt_instructions.txt '{ contents: [{ parts: [{ text: $prompt }] }] }' > payload.json

          # Using gemini-1.5-flash as it is the most stable current model
          curl -s -H "Content-Type: application/json" -d @payload.json "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=$GEMINI_API_KEY" > response.json

          jq -r '.candidates[0].content.parts[0].text' response.json | sed 's/^```json//' | sed 's/^```//' | sed 's/```$//' > gemini_output.txt

      - name: 4. Decide Action (Update Comment)
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            if (!fs.existsSync('gemini_output.txt')) return;
            
            const fullOutput = fs.readFileSync('gemini_output.txt', 'utf8');
            const separator = "---SPLIT---";
            let summary = "Documentation updated.";
            let readmeContent = fullOutput;

            if (fullOutput.includes(separator)) {
               const parts = fullOutput.split(separator);
               summary = parts[0].trim();
               readmeContent = parts[1].trim();
            }

            const labels = context.payload.pull_request ? context.payload.pull_request.labels.map(l => l.name) : [];
            const shouldCommit = labels.includes('generate-readme');

            if (shouldCommit) {
              console.log("LABEL FOUND! Preparing to commit...");
              fs.writeFileSync('README.md', readmeContent);
            } else {
              // UPDATE COMMENT LOGIC
              const header = "ü§ñ **Documentation Agent**";
              const body = `${header}\n\n` +
                           `### üìù Latest Changes Analysis:\n` +
                           `${summary}\n\n` +
                           `--- \n` +
                           `üëâ **To apply this update:** Add label **\`generate-readme\`** to this PR.\n\n` +
                           `<details><summary>üëÄ <strong>Preview Full README</strong> (Click to expand)</summary>\n\n` +
                           `\`\`\`markdown\n${readmeContent}\n\`\`\`\n` +
                           `</details>\n` +
                           `\n_Last analysis: ${new Date().toISOString()}_`;
              
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const botComment = comments.find(c => c.body.includes(header));

              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: body
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: body
                });
              }
            }

      - name: 5. Commit Changes (Safe Push)
        if: contains(github.event.pull_request.labels.*.name, 'generate-readme')
        run: |
          git config --global user.name "Gemini Docs Agent"
          git config --global user.email "actions@github.com"
          
          # Stage the new README
          git add README.md
          
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "docs: auto-update README.md [skip ci]"
            
            # CRITICAL FIX: Pull remote changes (rebase) before pushing
            # This prevents the "lost file" or "rejected push" issue
            git pull origin ${{ github.event.pull_request.head.ref }} --rebase --autostash
            
            # Push specifically to the PR branch
            git push origin HEAD:${{ github.event.pull_request.head.ref }}
          fi

      - name: 6. Always Remove Label
        if: contains(github.event.pull_request.labels.*.name, 'generate-readme')
        uses: actions/github-script@v6
        with:
          script: |
            console.log("Cleaning up label...");
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: 'generate-readme'
              });
            } catch (e) {
              console.log("Label already removed.");
            }
