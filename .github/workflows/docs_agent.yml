name: ü§ñ Documentation Agent (Gemini)

on:
  pull_request:
    types: [opened, synchronize, labeled]
  workflow_dispatch:

permissions:
  pull-requests: write
  contents: write

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - name: 1. Check out code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0

      - name: 2. Gather Data
        id: file_data
        run: |
          git fetch origin ${{ github.base_ref }}
          
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # Full Diff for README
            git diff origin/${{ github.base_ref }} HEAD -- . ":(exclude).github" ":(exclude).gitignore" > full_pr_diff.txt
            # Last Commit Diff for Change Log
            git diff HEAD~1 HEAD -- . ":(exclude).github" ":(exclude).gitignore" > last_commit_diff.txt
          else
            echo "Manual run." > full_pr_diff.txt
            echo "Manual run." > last_commit_diff.txt
          fi

          if [ -f "README.md" ]; then
            cp README.md current_readme.txt
          else
            echo "README.md file not found." > current_readme.txt
          fi
          
          git ls-files --exclude-standard | grep -v "^.github/" > file_tree.txt

      # --- STEP 3: GENERATE CONTENT (TEXT MODE - MORE ROBUST) ---
      - name: 3. Call Gemini API
        id: gemini_call
        env:
          REPO_NAME: ${{ github.event.repository.name }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          cat <<'EOF_PROMPT' > prompt.txt
          # TASK: DOCUMENTATION MAINTAINER
          
          ## GOAL:
          1. Write a concise **Change Log** based on the [LAST COMMIT DIFF].
          2. Write the full **Updated README** based on [FULL PR DIFF].
          
          ## OUTPUT FORMAT (STRICTLY FOLLOW SEPARATORS):
          
          START_CHANGE_LOG
          (Bulleted list of changes here)
          END_CHANGE_LOG
          
          START_README
          (Full Markdown content of README.md here)
          END_README
          
          ## GOLDEN STRUCTURE FOR README:
          ---
          **[GOLDEN_TEMPLATE]**
          # PROJECT_NAME_PH
          [Description]
          ## 1. Table of Contents
          ## 2. About The Project
          ## 3. Installation
          ## 4. Usage
          ## 5. Configuration
          ## 6. API Reference
          ## 7. Deployment
          ## 8. Roadmap
          ## 9. License
          Copyright ¬© 2025 Grid Dynamics Holdings, Inc. All rights reserved.
          (License text...)
          ---
          EOF_PROMPT

          sed -i "s/PROJECT_NAME_PH/$REPO_NAME/g" prompt.txt
          
          # Combine all inputs into one file for jq
          cat prompt.txt > full_input.txt
          echo -e "\n\n## LAST COMMIT DIFF:\n" >> full_input.txt
          cat last_commit_diff.txt >> full_input.txt
          echo -e "\n\n## FULL PR DIFF:\n" >> full_input.txt
          cat full_pr_diff.txt >> full_input.txt
          echo -e "\n\n## CURRENT README:\n" >> full_input.txt
          cat current_readme.txt >> full_input.txt

          jq -n --rawfile text full_input.txt '{ contents: [{ parts: [{ text: $text }] }] }' > payload.json

          curl -s -H "Content-Type: application/json" -d @payload.json "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=$GEMINI_API_KEY" > response.json

          # Extract text
          jq -r '.candidates[0].content.parts[0].text' response.json > gemini_full_response.txt

      # --- STEP 4: PARSE & ACT ---
      - name: 4. Process Response
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            if (!fs.existsSync('gemini_full_response.txt')) return;
            
            const fullText = fs.readFileSync('gemini_full_response.txt', 'utf8');
            
            // Simple parsing using markers
            let changeLog = "Updates found.";
            let readme = fullText;

            if (fullText.includes('START_CHANGE_LOG') && fullText.includes('END_CHANGE_LOG')) {
                changeLog = fullText.split('START_CHANGE_LOG')[1].split('END_CHANGE_LOG')[0].trim();
            }
            if (fullText.includes('START_README') && fullText.includes('END_README')) {
                readme = fullText.split('START_README')[1].split('END_README')[0].trim();
            }

            // Check label
            const labels = context.payload.pull_request ? context.payload.pull_request.labels.map(l => l.name) : [];
            const shouldCommit = labels.includes('generate-readme');

            if (shouldCommit) {
                console.log("LABEL FOUND! Writing file...");
                fs.writeFileSync('README.md', readme);
            } else {
                console.log("Updating comment...");
                const header = "ü§ñ **Documentation Agent**";
                const body = `${header}\n\n### üìù Change Log:\n${changeLog}\n\n---\nüëâ **Apply?** Add label **\`generate-readme\`**.\n\n<details><summary>üëÄ View README</summary>\n\n\`\`\`markdown\n${readme}\n\`\`\`\n</details>`;
                
                const { data: comments } = await github.rest.issues.listComments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                });
                const botComment = comments.find(c => c.body.includes(header));
                if (botComment) {
                    await github.rest.issues.updateComment({ owner: context.repo.owner, repo: context.repo.repo, comment_id: botComment.id, body: body });
                } else {
                    await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number, body: body });
                }
            }

      # --- STEP 5: COMMIT (If Label) ---
      - name: 5. Commit Changes
        if: contains(github.event.pull_request.labels.*.name, 'generate-readme')
        run: |
          git config --global user.name "Gemini Docs Agent"
          git config --global user.email "actions@github.com"
          git add README.md
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "docs: auto-update README.md [skip ci]"
            git push
          fi

      # --- STEP 6: REMOVE LABEL (ALWAYS) ---
      - name: 6. Remove Label
        if: always() && contains(github.event.pull_request.labels.*.name, 'generate-readme')
        uses: actions/github-script@v6
        with:
          script: |
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: 'generate-readme'
              });
            } catch (e) {
              console.log("Label already removed.");
            }
