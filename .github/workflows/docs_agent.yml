name: ü§ñ Documentation Agent (Lyra Edition v48)

on:
  pull_request:
    types: [opened, synchronize, labeled]
  workflow_dispatch:
    inputs:
      mode:
        description: 'Run Mode'
        required: true
        default: 'diff'
        type: choice
        options:
        - diff
        - full_scan

permissions:
  pull-requests: write
  contents: write

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - name: 1. Check out code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0

      - name: 2. Gather Data (Smart Context)
        id: file_data
        run: |
          git fetch origin ${{ github.base_ref }}
          
          # 1. –°–æ–±–∏—Ä–∞–µ–º DIFF (–ò–∑–º–µ–Ω–µ–Ω–∏—è)
          if [ "${{ github.event_name }}" == "pull_request" ]; then
             git diff origin/${{ github.base_ref }} HEAD -- . ":(exclude).github" ":(exclude).gitignore" > pr_diff.txt
          else
             echo "Manual Run" > pr_diff.txt
          fi

          # 2. –°–æ–±–∏—Ä–∞–µ–º –ö–û–ù–¢–ï–ö–°–¢ (–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª–æ–≤)
          echo "## PROJECT STRUCTURE:" > context.txt
          git ls-files --exclude-standard | grep -v "^.github/" | head -n 100 >> context.txt
          
          # –î–æ–±–∞–≤–ª—è–µ–º –∫–ª—é—á–µ–≤—ã–µ —Ñ–∞–π–ª—ã –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
          for dep_file in "requirements.txt" "package.json" "pom.xml" "go.mod"; do
             if [ -f "$dep_file" ]; then
                echo -e "\n## FILE: $dep_file" >> context.txt
                cat "$dep_file" >> context.txt
             fi
          done

          # 3. –ß–∏—Ç–∞–µ–º —Å—Ç–∞—Ä—ã–π README
          if [ -f "README.md" ]; then
            cp README.md current_readme.txt
          else
            echo "No README found." > current_readme.txt
          fi

      - name: 3. Call Gemini API (Lyra Optimized)
        id: gemini_call
        env:
          REPO_NAME: ${{ github.event.repository.name }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          # --- –§–û–†–ú–ò–†–û–í–ê–ù–ò–ï –ü–†–û–ú–ü–¢–ê ---
          cat <<'EOF_PROMPT' > prompt.txt
          # ROLE: Senior Technical Writer & Code Analyst

          ## INPUTS:
          1. **CONTEXT:** Project structure & dependencies.
          2. **DIFF:** The raw code changes in this PR.
          3. **OLD README:** Current documentation.

          ## OBJECTIVE:
          You must generate two distinct outputs enclosed in strict tags.

          ### PART 1: CHANGE LOG (For the PR Comment)
          Analyze the DIFF. Summarize *only* what changed.
          
          **‚õî CRITICAL CONSTRAINTS (MUST FOLLOW):**
          1. **NO FULL TEXT:** Do NOT output the full content of README.md or any file here.
          2. **NO WALLS OF TEXT:** Use bullet points only.
          3. **STRUCTURE:** Group changes by filename.

          **REQUIRED FORMAT for Change Log:**
          ### üìÇ `[Filename]`
          - **Change:** [Concise description of the edit]
          - **Why:** [Brief rationale]

          ### PART 2: THE UPDATED README (For the file)
          Take the "OLD README" and integrate the changes from "DIFF".
          - Keep the original structure.
          - Output the FULL Markdown content of the new README.

          ## OUTPUT WRAPPER (STRICT):
          START_CHANGE_LOG
          (Insert the File-by-File summary here)
          END_CHANGE_LOG

          START_README
          (Insert the FULL updated README.md content here)
          END_README
          EOF_PROMPT
          # -----------------------------

          sed -i "s/PROJECT_NAME_PH/$REPO_NAME/g" prompt.txt
          
          # –°–æ–±–∏—Ä–∞–µ–º payload
          cat prompt.txt > full_input.txt
          echo -e "\n\n## PROJECT CONTEXT:\n" >> full_input.txt
          cat context.txt >> full_input.txt
          echo -e "\n\n## CURRENT README:\n" >> full_input.txt
          cat current_readme.txt >> full_input.txt
          echo -e "\n\n## PR DIFF:\n" >> full_input.txt
          cat pr_diff.txt >> full_input.txt

          jq -n --rawfile text full_input.txt '{ contents: [{ parts: [{ text: $text }] }] }' > payload.json
          
          # –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ (–ò—Å–ø–æ–ª—å–∑—É–µ–º –º–æ–¥–µ–ª—å 1.5-flash –∫–∞–∫ —Å—Ç–∞–±–∏–ª—å–Ω—É—é, –ø–æ–º–µ–Ω—è–π—Ç–µ –Ω–∞ 2.0 –µ—Å–ª–∏ –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø)
          curl -s -H "Content-Type: application/json" -d @payload.json "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=$GEMINI_API_KEY" > response.json
          
          # –ü–∞—Ä—Å–∏–Ω–≥ –æ—Ç–≤–µ—Ç–∞
          jq -r '.candidates[0].content.parts[0].text' response.json > gemini_full_response.txt

      - name: 4. Process & Comment (Smart Logic)
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            if (!fs.existsSync('gemini_full_response.txt')) return;
            
            const fullText = fs.readFileSync('gemini_full_response.txt', 'utf8');
            
            // --- –ü–ê–†–°–ò–ù–ì –û–¢–í–ï–¢–ê GEMINI ---
            let changeLog = "Updates found.";
            let readme = fullText;

            if (fullText.includes('START_CHANGE_LOG') && fullText.includes('END_CHANGE_LOG')) {
                changeLog = fullText.split('START_CHANGE_LOG')[1].split('END_CHANGE_LOG')[0].trim();
            }
            if (fullText.includes('START_README') && fullText.includes('END_README')) {
                readme = fullText.split('START_README')[1].split('END_README')[0].trim();
            }

            const labels = context.payload.pull_request ? context.payload.pull_request.labels.map(l => l.name) : [];
            const shouldCommit = labels.includes('generate-readme');

            if (shouldCommit) {
                console.log("LABEL FOUND! Writing file...");
                fs.writeFileSync('README.md', readme);
            } else {
                // --- –õ–û–ì–ò–ö–ê –ö–û–ú–ú–ï–ù–¢–ê–†–ò–ï–í ---
                
                // 1. STICKY COMMENT (–ì–ª–∞–≤–Ω—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π —Å–æ —Å–ø–æ–π–ª–µ—Ä–æ–º)
                const header = "ü§ñ **Documentation Agent (Master Preview)**";
                const stickyBody = `${header}\n\n` +
                                   `–≠—Ç–æ –∞–∫—Ç—É–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç.\n` +
                                   `üëâ **–ß—Ç–æ–±—ã –ø—Ä–∏–º–µ–Ω–∏—Ç—å:** –ü–æ—Å—Ç–∞–≤—å—Ç–µ –º–µ—Ç–∫—É **\`generate-readme\`**.\n\n` +
                                   `<details><summary>üìú **–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–ª–Ω—ã–π —Ç–µ–∫—Å—Ç README** (–ù–∞–∂–º–∏—Ç–µ —á—Ç–æ–±—ã —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å)</summary>\n\n` +
                                   `\`\`\`markdown\n${readme}\n\`\`\`\n` +
                                   `</details>`;
                
                const { data: comments } = await github.rest.issues.listComments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                });
                
                const stickyComment = comments.find(c => c.body.includes(header));

                if (stickyComment) {
                    await github.rest.issues.updateComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        comment_id: stickyComment.id,
                        body: stickyBody
                    });
                } else {
                    await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: context.issue.number,
                        body: stickyBody
                    });
                }

                // 2. HISTORY COMMENT (–ê–∫–∫—É—Ä–∞—Ç–Ω—ã–π –ª–æ–≥ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
                // –≠—Ç–æ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ –≤ –ª–µ–Ω—Ç—É –∏ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–æ–ª–Ω–æ–≥–æ —Ñ–∞–π–ª–∞!
                const historyBody = `üöÄ **Update Analysis**\n\n` +
                                    `${changeLog}`;
                
                await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: historyBody
                });
            }

      - name: 5. Commit Changes
        if: contains(github.event.pull_request.labels.*.name, 'generate-readme')
        run: |
          git config --global user.name "Gemini Docs Agent"
          git config --global user.email "actions@github.com"
          git add README.md
          if git diff --staged --quiet; then
            echo "No changes."
          else
            git commit -m "docs: auto-update README.md [skip ci]"
            git push
          fi

      - name: 6. Remove Label
        if: always() && contains(github.event.pull_request.labels.*.name, 'generate-readme')
        uses: actions/github-script@v6
        with:
          script: |
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: 'generate-readme'
              });
            } catch (e) {}
